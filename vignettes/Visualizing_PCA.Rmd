---
title:  "Visualizing PCA"
author:
  - name: David T. Harvey^1^, Bryan A. Hanson^2^
    email: harvey@depauw.edu, hanson@depauw.edu
    affiliation: |
        1. Professor of Chemistry & Biochemistry, DePauw University, Greencastle IN USA.
        2. Professor Emeritus of Chemistry & Biochemistry, DePauw University, Greencastle IN USA.
date:  "`r Sys.Date()`"
output:
    bookdown::html_document2:
      toc: yes
      toc_depth: 2
      fig_caption: yes
      number_sections: false
vignette: >
    %\VignetteIndexEntry{LearnPCA 4: Visualizing PCA}
    %\VignetteKeywords{PCA}
    %\VignettePackage{LearnPCA}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
#link-citations: yes
#bibliography: PCA.bib
#biblio-style: plain
pkgdown:
  as_is: true
---

```{r SetUp, echo = FALSE, eval = TRUE, results = "hide"}
# R options & configuration:
set.seed(13)
rm(list = ls())
suppressPackageStartupMessages(library("knitr"))
suppressPackageStartupMessages(library("plot3D"))

# colors and color names
pcdata_col = "#3db7ed"
pcdata_colname = "light blue"
pcproj_col = "#f748a5"
pcproj_colname = "pink"
pcaxis_col = "#d55e00"
pcaxis_colname = "brown"
xyzaxis_col = "#000000"
xyzaxis_colname = "black"

# Stuff specifically for knitr:
opts_chunk$set(eval = TRUE, echo = FALSE, results = "hide")
opts_knit$set(eval.after = "fig.cap")
options(rmarkdown.html_vignette.check_title = FALSE)
```

<!-- This chunk inserts common info about all the vignettes -->

```{r, echo = FALSE, results = "asis"}
res <- knitr::knit_child("top_matter.md", quiet = TRUE)
cat(res, sep = '\n')
```

One simple explanation of a PCA analysis is that it is a reorientation of the set of axes we use to describe the location of data points in space. Suppose we have *n* measurements and 100 samples. First, we plot the data in *n*-dimensional space using *n* mutually perpendicular axes, one for each of the *n* measurements. Then, we rotate the set of *n* axes until one of them passes through the cloud of 100 data points in a way that explains as much of the variation in the data as possible; this becomes our first principal component axis. Once we find this axis, we project the cloud of 100 data points onto the $n - 1$ dimensional surface that is perpendicular to the first principal component and repeat the process: rotate the axes, find the next principal component, and project the data onto the next lower dimension.

*DTH: In the conceptual introduction to PCA, I encouraged the reader to think of variation as the signal, so when we say "explains as much of the variation as possible" it should be read as "explains as much of the signal as possible". Not sure if you like this phrasing; but if you do, it would be good to continue to use it here.* **I'll have to chew on this a bit. To an analytical chemist, a signal is something you measure that conveys information. In that sense a PCA is not really explaining as much of the signal in the data as possible, but redefining the original signals in a way that provides more useful information. Thus, for the glass data, the individual measurements, each a signal, convey less useful information about the origin of the samples than the first two PCs, which are more useful signals for classify the samples. Still, I do see that one might see more variation as more noise, which might be a point of confusion.**

This definition is simple to write but it is difficult to visualize because we are limited by our inability to see in more than three dimensions. A flock of birds that suddenly takes flight is an easy to understand description of a cloud of data in three dimensions. But what does a cloud of data look like in four (or more) dimensions? The goal of this vignette is to start with a cloud of data in three dimensions and visually explore how the shape of this cloud changes as we go through the process of completing a PCA analysis.

```{r prepData}
# set coordinates for center of ellipsoid
x0 = 0
y0 = 0
z0 = 0

# set dimensions of ellipsoid relative to center; values chosen to
# make x-axis more important than y-axis, which is more important
# than the z-axis; thus pc1 is x-axis, pc2 is y-axis, pc3 = z-axis
xa = 15
yb = 9
zc = 2

# generate set of random points within the ellipsoid's boundaries
# done by first generating random points within rectangular solid that
# encompasses the ellipsoid
set.seed(13)
x = runif(400, min = -xa, max = xa)
y = runif(400, min = -yb, max = yb)
z = runif(400, min = -zc, max = zc)

# determine which points have (x,y,z) values that are inside the
# ellipsoid using equation for ellipsoid; a negative value for
# check means the point is inside of ellipsoid; flag as id
check = (x - x0)^2/xa^2 + (y - y0)^2/yb^2 + (z - z0)^2/zc^2 - 1
id = which(check < 0)

# extract sets of (x,y,z) points inside of ellipsoid
xe = x[id]
ye = y[id]
ze = z[id]

# function to rotate data and axes; a, b, and g are angles for rotation
# around the z, y, and x axes; see en.wikipedia.org/wiki/Rotation_matrix
rot = function(a = 10, b = 10, g = 10, x = xe, y = ye, z = ze){
  xrot = cos(a)*cos(b)*x + (cos(a)*sin(b)*sin(g) - sin(a)*cos(g))*y + (cos(a)*sin(b)*cos(g) + sin(a)*sin(g))*z
  yrot = sin(a)*cos(b)*x + (sin(a)*sin(b)*sin(g) + cos(a)*cos(g))*y + (sin(a)*sin(b)*cos(g) - cos(a)*sin(g))*z
  zrot = -sin(b)*x + cos(b)*sin(g)*y + cos(b)*cos(g)*z
  out = list("xrot" = xrot,
             "yrot" = yrot,
             "zrot" = zrot)
}

# original pc axes (same as x,y,z axes)
xpc1 = c(-xa,xa)
ypc1 = c(0,0)
zpc1 = c(0,0)
xpc2 = c(0,0)
ypc2 = c(-xa,xa)
zpc2 = c(0,0)
xpc3 = c(0,0)
ypc3 = c(0,0)
zpc3 = c(-xa,xa)

# rotate the pc axes
pc1 = rot(x = xpc1, y = ypc1, z = zpc1)
pc2 = rot(x = xpc2, y = ypc2, z = zpc2)
pc3 = rot(x = xpc3, y = ypc3, z = zpc3)

# rotate the original data
rotdata = rot()

# pca results in case they are of interest
pc_results = prcomp(data.frame(rotdata$xrot, rotdata$yrot, rotdata$zrot))
```

## Visuallizing The Original Data Set

The data for this vignette consists of `r length(id)` points drawn at random from within the boundaries of an ellipsoid (think football) that has a length of `r 2*xa`, a width of `r 2*yb`, and a height of `r 2*zc`. Figure 1 shows the three-dimensional cloud of data as `r pcdata_colname` points and the three axes that define the data as `r xyzaxis_colname` lines. These axes are not the principal component axes, they are the usual x, y and z axes.

```{r origData, fig.cap=paste("Three-dimensional plot of data (", pcdata_colname, "points) showing the x, y, and z-axes (",xyzaxis_colname, "lines) that represent the three measured variables.")}
# plot rotated data and original pc axes (original x,y,z)
scatter3D(x = rotdata$xrot, y = rotdata$yrot, z = rotdata$zrot,
          pch = 19, col = pcdata_col, bty = "b2", cex = 0.3,
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa),
          phi = 10, theta = 50, ticktype = "detailed")
points3D(x = xpc1, y = ypc1, z = zpc1, type = "l", col = xyzaxis_col,
         lwd = 2, lty = 1, add = TRUE)
points3D(x = xpc2, y = ypc2, z = zpc2, type = "l", col = xyzaxis_col,
         lwd = 2, lty = 1, add = TRUE)
points3D(x = xpc3, y = ypc3, z = zpc3, type = "l", col = xyzaxis_col,
         lwd = 2, lty = 1, add = TRUE)
```

## The First Principal Component

Although the three axes in Figure 1 define the location of the individual data points in space, any set of three mutually perpendicular axes will accomplish the same thing. Our goal is to find three specific axes such that the first axis conveys the most information about the data and the third, and final axis explains conveys the least information about the data.

To help us visualize where the first principal component axis lies, Figure 2 shows the same cloud of data as `r pcdata_colname` points in three dimensions, and projections of the data, as `r pcproj_colname` points, onto the two-dimensional x,y-plane, the y,z-plane, and the x,z-plane (in other words, the data is projected onto the "walls" of the figure). The three projections are consistent with an ellipsoid whose length is greater than its width (see the x,y-plane), and whose width is greater than its height (see y,z-plane).[^1]

```{r pc1a, fig.cap=paste("The data from Figure 1 (as", pcdata_colname, "points) and their projection onto the x,y-plane, the y,z-plane, and the x,z-plane (as", pcproj_colname," points).")}
scatter3D(x = rotdata$xrot, y = rotdata$yrot, z = rotdata$zrot,
          pch = 19, col = pcdata_col, bty = "b2", cex = 0.3,
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa),
          phi = 10, theta = 50, ticktype = "detailed")
scatter3D(x = rotdata$xrot, y = rotdata$yrot, z = rep(-xa, length(id)),
          pch = 19, col = pcproj_col, cex = 0.2, add = TRUE)
scatter3D(x = rep(-xa, length(id)), y = rotdata$yrot, z = rotdata$zrot,
          pch = 19, col = pcproj_col, cex = 0.2, add = TRUE)
scatter3D(x = rotdata$yrot, y = rep(xa, length(id)), z = rotdata$zrot,
          pch = 19, col = pcproj_col, cex = 0.2, add = TRUE)
```

As suggested by Figure 2, if we run the PCA and display the first principal component axis, we see that it runs diagonally from the lower-left to the upper-right, from values of x, y, and z that are negative to values of x, y, and z that are positive. Figure 3 shows the first principal component axis relative to the three-dimensional cloud of data seen in Figure 1 and Figure 2. The first principal component accounts for `r round(100 * summary(pc_results)$importance[2,1], digits = 1)`% of the variation in the data.

**There is an interesting philosophical question here. Although I added a prcomp analysis into the prepData code block so that it is available---and used it to report variances explained by the PCs---I do not use it to define the PC axes. I'm "cheating" a bit here. The original data is defined as an ellipsoid with values along the x-axis having a greater range than the values along the y-axis, which have a greater range than the values along the z-axis. The theoretical PC axes are, then, the x-axis, the y-axis, and the z-axis, respectively. Including lots of data points means that the theoretical and calculated PCs should align closely. I then used a rotation function to rotate the data and the theoretical PC axes in space so that there is no obvious alignment of the PCs with the x, y, and z-axes. My goal is visual, so rotating the theoretical PCs seems okay. Doing things this way made it much easier to do the plotting. **

*DTH: I think it would be nice to have the component axes in a different color from the usual x, y, z axes.  I also think in the long run we should probably choose color-blind friendly colors (which also work for normal vision folks). I will dig these up and send you a sample.  Also, might be wise to give our internal colors names early on, then call them by that name, so that we can change or minds easily and only fix it in one place.  Something like "xyz_ax_col <- some_color", "pc_ax_col" etc.  And perhaps we should have names for those colors since they are used in the captions etc.  So perhaps xyx_ax_col_name <- "red".* **Done. Feel free to play around with colors; they are defined in the first code block. I also added the line opts_knit$set(eval.after = "fig.cap") in the first code block to allow the figure captions to use paste( ) so that the colornames can be added there as variables.**

```{r pc1b, fig.cap=paste("The data from Figure 1 (as", pcdata_colname, "points) and the first principal component axis (as a", pcaxis_colname, "line).")}
scatter3D(x = rotdata$xrot, y = rotdata$yrot, z = rotdata$zrot,
          pch = 19, col = pcdata_col, bty = "b2", cex = 0.3,
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa),
          phi = 10, theta = 50, ticktype = "detailed")
points3D(x = pc1$xrot, y = pc1$yrot, z = pc1$zrot, type = "l", col = pcaxis_col,
        lwd = 2, lty =1, add = TRUE)
# just stashing this here for now
# points3D(x = pc1$xrot, y = pc1$yrot, z = c(-xa,-xa), type = "l", col = pcaxis_col,
#         lwd = 2, lty =3, add = TRUE)
# points3D(x = pc1$xrot, y = c(xa,xa), z = pc1$zrot, type = "l", col = pcaxis_col,
#         lwd = 2, lty =3, add = TRUE)
# points3D(x = c(-xa,-xa), y = pc1$yrot, z = pc1$zrot, type = "l", col = pcaxis_col,
#         lwd = 2, lty =3, add = TRUE)
```

## The Second Principal Component

To visualize the second principal component axis, we first project the data From Figure 1 onto a plane perpendicular to the first principal component axis in Figure 3. Figure 4 shows this where the `r pcaxis_colname` line is the first principal component, the `r pcdata_colname` box highlights a portion of the plane perpendicular to the first principal component axis, and the points in `r pcdata_colname` are the projections of the original data from Figure 1 and Figure 2 onto this plane.

```{r pc2a, fig.cap=paste("The first principal component (",pcaxis_colname, "line) and the projection of the original data (",pcdata_colname,"points) onto the plane perpendicular to the first principal component (shown with a", pcdata_colname, "boundary).")}
proj = rot(x = rep(0,length(id)), y = ye, z = ze)
scatter3D(x = proj$xrot, y = proj$yrot, z = proj$zrot,
          pch =19, col = pcdata_col, cex = 0.2, ticktype = "detailed",
          phi = 10, theta = 50, bty = "b2",
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa))
polygon3D(x = c(pc3$xrot[2], pc2$xrot[2], pc3$xrot[1], pc2$xrot[1]),
          y = c(pc3$yrot[2], pc2$yrot[2], pc3$yrot[1], pc2$yrot[1]),
          z = c(pc3$zrot[2], pc2$zrot[2], pc3$zrot[1], pc2$zrot[1]),
          col = adjustcolor("white", alpha.f = 0.1), border = pcdata_col,
          add = TRUE)
points3D(x = pc1$xrot, y = pc1$yrot, z = pc1$zrot, type = "l", col = pcaxis_col,
         lwd = 2, lty = 1, add = TRUE)
```

The cloud of data in the two-dimensional plane runs diagonally from the lower left to the upper right, as we see in Figure 5, where the dashed `r pcaxis_colname` line is the second principal component axis. The second principal component accounts for `r round(100 * summary(pc_results)$importance[2,2], digits = 1)`% of the variation in the data; together, the first two principal components account for `r round(100 * summary(pc_results)$importance[3,2], digits = 1)`% of the variation in the data.

```{r pc2b, fig.cap=paste("The result of adding the second principal component axis to Figure 3. The first principal component axis is the solid", pcaxis_colname, "line and the second principal component axis is the dashed", pcaxis_colname, "line.")}
scatter3D(x = proj$xrot, y = proj$yrot, z = proj$zrot,
          pch =19, col = adjustcolor(pcdata_col,alpha.f = 0.5), cex = 0.2,
          ticktype = "detailed",phi = 10, theta = 50, bty = "b2",
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa))
points3D(x = pc1$xrot, y = pc1$yrot, z = pc1$zrot, type = "l", col = pcaxis_col,
         lwd = 2, lty = 1, add = TRUE)
points3D(x = pc2$xrot, y = pc2$yrot, z = pc2$zrot, type = "l", col = pcaxis_col,
         lwd = 2, lty = 2, add = TRUE)
```

## The Third Principal Component

With the first two principal components in place, the last principal component is the only axis we can draw that is perpendicular to the two existing principal components. Figure 6 shows the original cloud of data and all three principal component axes. In this example, the first principal component is aligned with ellipsoid's length, the second principal component is aligned with its width, and the third principal component is aligned with its height.

```{r pc3, fig.cap=paste("The original data (", pcdata_colname, "points) and the three three principal component axes (", pcaxis_colname, "lines). The solid line is the first principal component, the dashed line is the second principal component, and the dotted line is the third principal component.")}
scatter3D(x = rotdata$xrot, y = rotdata$yrot, z = rotdata$zrot,
          pch = 19, col = pcdata_col, bty = "b2", cex = 0.3,
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa),
          phi = 10, theta = 50, ticktype = "detailed")
points3D(x = pc1$xrot, y = pc1$yrot, z = pc1$zrot, type = "l", col = pcaxis_col,
        lwd = 2, lty =1, add = TRUE)
points3D(x = pc2$xrot, y = pc2$yrot, z = pc2$zrot, type = "l", col = pcaxis_col,
         lwd = 2, lty = 2, add = TRUE)
points3D(x = pc3$xrot, y = pc3$yrot, z = pc3$zrot, type = "l", col = pcaxis_col,
         lwd = 2, lty = 3, add = TRUE)
```

## How PCA Changes the Data Cloud

Although you can see this in the figures above, it merits additional emphasis here: the process of reducing the data to a lower dimension after we identify a principal component axis results in the data becoming more compact with less variation in the range of individual values. This is what we mean when we say that each principal component axis explains the greatest variability in the data in its current form. The following figure shows how the data cloud becomes smaller in size as we decrease the dimensions of the data from (a) three, to (b) two, and to (c) one dimension; panel (d) provides a closer view of panel (c), making the individual points visible. The `r pcaxis_colname` lines in (a), (b), and (c) show the principal component axes at each step in the analysis.

```{r dataClouds, fig.height=8, fig.cap=paste("How the data (in", pcdata_colname, ") changes during PCA: (a) the original data in three dimensions; (b) the data after reducing to two dimensions; (c) the data after reducing to one dimension; (d) close up of (c) making it easier to see the individual data points. The", pcaxis_colname, "lines are the principal component axes at each step in the PCA analysis.")}
old.par = par(mfrow = c(2,2))
scatter3D(x = rotdata$xrot, y = rotdata$yrot, z = rotdata$zrot,
          pch = 19, col = pcdata_col, bty = "b2", cex = 0.2,
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa),
          phi = 10, theta = 50, ticktype = "detailed",
          main = "(a) Original Data Cloud")
points3D(x = pc1$xrot, y = pc1$yrot, z = pc1$zrot, type = "l", col = "red",
         lwd = 0.5, lty = 1, add = TRUE)
scatter3D(x = proj$xrot, y = proj$yrot, z = proj$zrot,
          pch =19, col = pcdata_col, cex = 0.2, ticktype = "detailed",
          phi = 10, theta = 50, bty = "b2",
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa),
          main = "(b) After Removing First PC")
points3D(x = pc1$xrot, y = pc1$yrot, z = pc1$zrot, type = "l", col = "red",
         lwd = 0.5, lty = 1, add = TRUE)
points3D(x = pc2$xrot, y = pc2$yrot, z = pc2$zrot, type = "l", col = "red",
         lwd = 0.5, lty = 1, add = TRUE)
proj2 = rot(x = rep(0,length(id)), y = rep(0,length(id)), z = ze)
scatter3D(x = proj2$xrot, y = proj2$yrot, z = proj2$zrot,
          pch =19, col = pcdata_col, cex = 0.2, ticktype = "detailed",
          phi = 10, theta = 50, bty = "b2",
          xlim = c(-xa,xa), ylim = c(-xa,xa), zlim = c(-xa,xa),
          main = "(c) After Removing Second PC")
points3D(x = pc1$xrot, y = pc1$yrot, z = pc1$zrot, type = "l", col = "red",
         lwd = 0.5, lty =1, add = TRUE)
points3D(x = pc2$xrot, y = pc2$yrot, z = pc2$zrot, type = "l", col = "red",
         lwd = 0.5, lty = 1, add = TRUE)
points3D(x = pc3$xrot, y = pc3$yrot, z = pc3$zrot, type = "l", col = "red",
         lwd = 0.5, lty = 1, add = TRUE)
scatter3D(x = proj2$xrot, y = proj2$yrot, z = proj2$zrot,
          pch =19, col = pcdata_col, cex = 0.2, ticktype = "detailed",
          phi = 10, theta = 50, bty = "b2",
          xlim = c(-2,2), ylim = c(-2,2), zlim = c(-2,2),
          main = "(d) Close Up of (c)")
par(old.par)
```



## Final Thoughts

The data sets in LearnPCA---and, more importantly, the data sets from your teaching and research projects---likely have significantly more than three variables. Although you cannot plot and examine your data set as we did here for a system with three variables, the process remains the same: rotate the coordinate system to find the principal component axis that best explains the data in *n* dimensions, project the data onto the $n - 1$ dimensional surface that is perpendicular to your principal component axis, and repeat until original set of *n* axes is replaced with a set of *n* principal component axes.

[^1]: Note that the projection onto the x,y-plane shows less structure, with the points forming an ellipse that is nearly a circle. *DTH: I thought you were going to talk about this nearly random distribution as the reason this is the 3rd PC... doesn't explain much signal.  Maybe we should include the scree plot here to back this up?* **The data in the x,y plane isn't evidence of the third PC, which actually runs perpendicular to the long axis of the data in the yz plane. I increased the number of data points and changed the length and width of the ellipsoid so that it is easier to see that the points in the x,y plane are not approaching a circle. The projection onto the x,y plane shows that the first PC runs diagonally from (-x,-y) values to (+x,+y) values and the projections on the x,z and the y,z planes show that the first PC also angles upward. The second and the third PC only become evident when you reduce the data cloud down into two dimensions and then one dimension. Probably don't need this footnote.**
